- 1. Hablar del GC de Lua y como hay leaks en C++ con luabridge por alguna razón, y también sin luabridge. Hay que llamar a funciones de lua como lua_ldofile o dostring que por debajo triggerean la recolección

- 2. Hablar de la implementación de C++ con callbacks en lua, y de C++ render + simulación en lua

- 3. Hablar de la posibilidad de plugins (dll), wasm con existsm con C++ o Rust

- 4. Migración todo a lua con luajit basado en ffi

- 5. El problema de multithreading 1: Paso de parámetros. Lovedata, casteos ffi y funciones como string

- 6. El problema del multithreading 2: Coste de reiniciar un thread debido a los require y como lo solucioné a base de cablear

- 7. El problema del multithreading 3. Sincronización + sesgo del orden de actualización que también afecta a 1 solo hilo. Las pruebas ejecutando por chunks en un solo hilo satisfacen que el resultado será igual al paralelizar.

- 8. El doble buffer con byte de escritura, el santo grial.

- 9. Investigación: Todos los proyectos que son simulaciones de partículas, o bien las tienen cableada, o bien permiten extender mediante un lenguaje de scripting, en cuyo caso, no hay interop, todo está escrito en el mismo lenguaje.

- 10. Objetivo final: Poder modear la simulación con tanta facilidad está guay, pero da lugar a que los usuarios introduzcan fallos, controlar eso es molesto. Esta es la excusa que uso para decir que quiero meter scripting visual. LuaJit facilita esto mucho, puedo crear bloques, generar el string de una función y compilarla on the fly. Esto también es posible en C++ de forma distinta, pero en Lua es más sencillo, también facilita la serialización de las partículas. 

- 11. Próximos pasos: 

  11.1: El sistema de multithreading y chunks lo tengo cableado para el número de núcleos de mi procesador. Habría que automatirzarlo. En caso de single thread no hace falta usar el doble buffer, es un overhead innecesario, pero lo mantendré de todas formas para que el resultado de la simulación sea igual con un núcleo que con varios. Alternativamente, puedo camuflar esto en un modo "alto rendimiento", que usa esta técnica de doble buffer, y otro "bajo rendimiento", que no usa esta técnica y solo usa un thread, pero logra una simulación algo más estable.

  11.2: No es lo mismo preparar un api de scripting para un modder, que para nosotros, asumiendo ese objetivo, lo próximo es ampliar el sistema y organizar el código para poder empezar a trabajar en el scripting visual con una base sólida. IMGUI es una librería que suele usarse para tooling y no para proyectos en sí. Powder toy usa un GUI muy de programador pero funcional, en nuestro sistema propongo usar IMGUI porque es sencillo de usar y visualmente es aceptable. En caso de resultar ser un problema, se cambiaría

- 11.3: Optimización: La simulación ahora mismo funciona bien, pero uso algunas variables globales a modo de Singleton y eso no es muy bueno, lo ideal es convertir las variables globales en upvalues, a pesar de que Luajit hace optimizaciones prediciendo hashes, tengo indicios de que estas optimizaciones en esta simulación aportan rendimiento. Basarme en la doc de luajit y http://www.lua.org/gems/sample.pdf

- 11.4: QOL: Volverá el registro de partículas para configurar propiedades globales como la densidad que pueden ser útiles para scriptear algunos comportamientos

- 12. Versión de Jonathan. Yo voy a continuar el desarrollo de esto sea o no para el TFG, ahora bien. Esto significa que si Jonathan consigue demostrar la viabilidad del proyecto en GPU, podríamos hacerlo  procesando todo en GPU sacrificando la flexibilidad de mi sistema. Las partículas serían las que nosotros definamos, pero podríamos llegar a tener millones.